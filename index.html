<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="mobile-web-app-capable" content="yes" />
    <title>Matcha3!</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@500;700;900&display=swap");

      * {
        box-sizing: border-box;
      }

      html {
        height: 100%;
        background: #667eea;
      }

      body {
        margin: 0;
        padding: 0;
        font-family:
          "Noto Sans JP",
          -apple-system,
          sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        background-attachment: fixed;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        color: #fff;
      }

      .game-container {
        text-align: center;
        padding: 20px;
      }

      h1 {
        margin: 0 0 30px 0;
        font-size: 3em;
        font-weight: 900;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
      }

      .stats {
        display: flex;
        justify-content: center;
        margin-bottom: 20px;
        gap: 20px;
      }

      .stat {
        background: rgba(255, 255, 255, 0.15);
        padding: 15px 30px;
        border-radius: 20px;
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255, 255, 255, 0.3);
        font-size: 1.1em;
      }

      .stat span {
        font-weight: bold;
        font-size: 1.3em;
        color: #ffd700;
      }


      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      .game-board {
        display: inline-grid;
        grid-template-columns: repeat(6, 85px);
        grid-template-rows: repeat(6, 85px);
        gap: 8px;
        background: rgba(0, 0, 0, 0.3);
        padding: 20px;
        border-radius: 20px;
        position: relative;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      }

      .tile {
        width: 85px;
        height: 85px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        user-select: none;
        border-radius: 12px;
        border: 3px solid transparent;
        font-size: 2em;
        font-weight: 700;
        color: #333;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      /* Simple color coding for each script type */
      .tile.hiragana {
        background: #ffb6c1;
        border-color: #ff69b4;
      }

      .tile.katakana {
        background: #87ceeb;
        border-color: #4682b4;
      }

      .tile.romaji {
        background: #90ee90;
        border-color: #32cd32;
      }

      /* Unavailable tiles that can't be matched yet */
      .tile.unavailable {
        background: #808080;
        border-color: #606060;
        opacity: 0.6;
        cursor: not-allowed;
      }

      /* Faded state for tiles of same type */
      .tile.faded {
        opacity: 0.15;
        transform: scale(0.9);
        cursor: not-allowed;
        filter: grayscale(50%);
      }

      .tile.empty {
        background: transparent;
        border: none;
        box-shadow: none;
        cursor: default;
        pointer-events: none;
      }

      .tile:not(.faded):not(.empty):hover {
        transform: translateY(-3px) scale(1.05);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      }

      .tile.selected {
        transform: scale(1.1);
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        border-color: #ffd700 !important;
        border-width: 4px;
      }

      .tile.match-animation {
        animation: matchDisappear 0.6s ease forwards;
      }

      @keyframes matchDisappear {
        0% {
          transform: scale(1) rotate(0deg);
          opacity: 1;
        }
        50% {
          transform: scale(1.3) rotate(180deg);
        }
        100% {
          transform: scale(0) rotate(360deg);
          opacity: 0;
        }
      }

      .tile.shake {
        animation: shake 0.5s ease;
      }

      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        10%,
        30%,
        50%,
        70%,
        90% {
          transform: translateX(-8px);
        }
        20%,
        40%,
        60%,
        80% {
          transform: translateX(8px);
        }
      }

      .error-pulse {
        animation: errorPulse 0.5s ease;
      }

      @keyframes errorPulse {
        0%,
        100% {
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        50% {
          background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
        }
      }

      .match-line {
        position: absolute;
        height: 3px;
        background: #ffd700;
        transform-origin: left center;
        pointer-events: none;
        z-index: 10;
        border-radius: 2px;
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        opacity: 0.8;
      }

      .combo-text {
        position: absolute;
        font-size: 2.5em;
        font-weight: 900;
        animation: comboFloat 1.5s ease-out forwards;
        pointer-events: none;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
        color: #ffd700;
        z-index: 100;
      }

      @keyframes comboFloat {
        0% {
          transform: translate(-50%, -50%) scale(0);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -120px) scale(1.5);
          opacity: 0;
        }
      }

      button {
        background: linear-gradient(135deg, #ffd700, #ffed4e);
        color: #333;
        border: none;
        padding: 15px 35px;
        font-size: 1.2em;
        font-weight: bold;
        border-radius: 30px;
        cursor: pointer;
        margin: 10px 5px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
      }

      button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(255, 215, 0, 0.5);
      }

      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .legend {
        margin-top: 30px;
        display: flex;
        justify-content: center;
        gap: 40px;
        background: rgba(255, 255, 255, 0.1);
        padding: 15px 30px;
        border-radius: 20px;
        backdrop-filter: blur(10px);
        transform: scale(0.75);
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 1.1em;
      }

      .legend-box {
        width: 30px;
        height: 30px;
        border-radius: 6px;
        border: 2px solid;
      }

      .legend-box.hiragana {
        background: #ffb6c1;
        border-color: #ff69b4;
      }

      .legend-box.katakana {
        background: #87ceeb;
        border-color: #4682b4;
      }

      .legend-box.romaji {
        background: #90ee90;
        border-color: #32cd32;
      }

      .message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: #fff;
        padding: 30px 50px;
        border-radius: 20px;
        font-size: 2em;
        font-weight: bold;
        z-index: 1000;
        display: none;
      }

      .message.show {
        display: block;
        animation: messagePopup 2s ease forwards;
      }

      @keyframes messagePopup {
        0% {
          transform: translate(-50%, -50%) scale(0);
          opacity: 0;
        }
        20% {
          transform: translate(-50%, -50%) scale(1.1);
          opacity: 1;
        }
        80% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 0;
        }
      }

      .particle {
        position: absolute;
        pointer-events: none;
        font-size: 2em;
        animation: particle 1s ease-out forwards;
        z-index: 50;
      }

      @keyframes particle {
        0% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
        100% {
          transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy)))
            scale(0);
          opacity: 0;
        }
      }
      
      .spirit-text {
        position: absolute;
        pointer-events: none;
        font-size: 1.8em;
        font-weight: 700;
        z-index: 60;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        padding: 4px 8px;
        border-radius: 6px;
        border: 2px solid;
      }
      
      .spirit-text.hiragana {
        background: #ffb6c1;
        border-color: #ff69b4;
        color: #333;
      }
      
      .spirit-text.katakana {
        background: #87ceeb;
        border-color: #4682b4;
        color: #333;
      }
      
      .spirit-text.romaji {
        background: #90ee90;
        border-color: #32cd32;
        color: #333;
      }
      
      .spirit-text.float-up {
        animation: floatUp 1.5s ease-out forwards;
      }
      
      .spirit-text.float-down {
        animation: floatDown 1.5s ease-out forwards;
      }
      
      @keyframes floatUp {
        0% {
          transform: translate(-50%, -50%) scale(0.8);
          opacity: 0;
        }
        20% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -200%) scale(0.9);
          opacity: 0;
        }
      }
      
      @keyframes floatDown {
        0% {
          transform: translate(-50%, -50%) scale(0.8);
          opacity: 0;
        }
        20% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, 100%) scale(0.9);
          opacity: 0;
        }
      }

      .progress-bar {
        margin: 10px auto 5px;
        width: 580px; /* Same as game board */
        height: 6px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 3px;
        overflow: hidden;
        position: relative;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #ffd700, #ffed4e);
        width: 0%;
        transition: width 0.5s ease;
        border-radius: 3px;
      }


      .needed-types {
        margin: 10px 0;
        font-size: 1.2em;
        min-height: 30px;
        color: #ffd700;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      /* Mobile Responsive Styles */
      @media (max-width: 768px) {
        body {
          padding: 5px;
        }

        .game-container {
          padding: 5px;
          width: 100%;
          max-width: 100vw;
        }

        h1 {
          font-size: 2em;
          margin: 0 0 15px 0;
        }

        .stats {
          flex-wrap: wrap;
          gap: 10px;
          margin-bottom: 10px;
        }

        .stat {
          padding: 10px 15px;
          font-size: 0.9em;
          flex: 1;
          min-width: calc(33% - 10px);
        }

        .stat span {
          font-size: 1.1em;
        }

        .needed-types {
          font-size: 1em;
          margin: 5px 0;
        }

        /* Calculate tile size based on viewport width */
        .game-board {
          width: calc(100vw - 20px);
          max-width: 420px;
          height: calc(100vw - 20px);
          max-height: 420px;
          padding: 10px;
          gap: 4px;
          grid-template-columns: repeat(6, 1fr);
          grid-template-rows: repeat(6, 1fr);
        }

        .tile {
          width: 100%;
          height: 100%;
          font-size: 1.5em;
          border-radius: 8px;
          border-width: 2px;
        }

        .progress-bar {
          width: calc(100vw - 20px);
          max-width: 420px;
          height: 5px;
          margin: 5px auto 15px;
        }

        button {
          padding: 14px 30px;
          font-size: 1.1em;
          margin: 5px;
          -webkit-tap-highlight-color: transparent;
          touch-action: manipulation;
        }

        .legend {
          gap: 20px;
          padding: 10px 15px;
          transform: scale(1);
          margin-top: 15px;
          flex-wrap: wrap;
        }

        .legend-item {
          font-size: 0.9em;
          gap: 5px;
        }

        .legend-box {
          width: 20px;
          height: 20px;
        }

        .message {
          font-size: 1.5em;
          padding: 20px 30px;
          width: 90%;
          max-width: 300px;
        }

        .combo-text {
          font-size: 1.8em;
        }

        .particle {
          font-size: 1.5em;
        }

        /* Prevent text selection on mobile */
        * {
          -webkit-user-select: none;
          -webkit-touch-callout: none;
          user-select: none;
        }

        /* Ensure full height on mobile */
        html,
        body {
          height: 100%;
          min-height: 100vh;
          overflow: hidden;
          position: fixed;
          width: 100%;
        }

        /* Ensure gradient background is applied */
        body {
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          background-attachment: fixed;
        }
      }

      /* Very small phones */
      @media (max-width: 360px) {
        h1 {
          font-size: 1.5em;
        }

        .stat {
          font-size: 0.8em;
          padding: 8px 12px;
        }

        .game-board {
          width: calc(100vw - 15px);
          height: calc(100vw - 15px);
        }

        .tile {
          font-size: 1.2em;
        }

        button {
          font-size: 1em;
          padding: 12px 24px;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <h1>Matcha3! üçµ</h1>
      <div class="stats">
        <div class="stat">Score: <span id="score">0</span></div>
        <div class="stat">
          Matches: <span id="matches">0</span> /
          <span id="totalMatches">12</span>
        </div>
        <div class="stat timer">Time: <span id="timer">0s</span></div>
      </div>
      <div class="needed-types" id="neededTypes"></div>
      <div class="game-board" id="gameBoard"></div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div id="charStatsDebug" style="display: none; color: white; margin-top: 20px; font-size: 0.9em;"></div>
      <div>
        <button onclick="initGame()" id="newGameBtn">New Game</button>
        <button onclick="showHint()" id="hintBtn">Show Hint</button>
      </div>
      <div class="legend">
        <div class="legend-item">
          <div class="legend-box hiragana"></div>
          <span>Hiragana („Å≤„Çâ„Åå„Å™)</span>
        </div>
        <div class="legend-item">
          <div class="legend-box katakana"></div>
          <span>Katakana („Ç´„Çø„Ç´„Éä)</span>
        </div>
        <div class="legend-item">
          <div class="legend-box romaji"></div>
          <span>Romaji (ABC)</span>
        </div>
      </div>
    </div>

    <div class="message" id="message"></div>

    <script>
      const kanaMap = [
        { hiragana: "„ÅÇ", katakana: "„Ç¢", romaji: "a" },
        { hiragana: "„ÅÑ", katakana: "„Ç§", romaji: "i" },
        { hiragana: "„ÅÜ", katakana: "„Ç¶", romaji: "u" },
        { hiragana: "„Åà", katakana: "„Ç®", romaji: "e" },
        { hiragana: "„Åä", katakana: "„Ç™", romaji: "o" },
        { hiragana: "„Åã", katakana: "„Ç´", romaji: "ka" },
        { hiragana: "„Åç", katakana: "„Ç≠", romaji: "ki" },
        { hiragana: "„Åè", katakana: "„ÇØ", romaji: "ku" },
        { hiragana: "„Åë", katakana: "„Ç±", romaji: "ke" },
        { hiragana: "„Åì", katakana: "„Ç≥", romaji: "ko" },
        { hiragana: "„Åï", katakana: "„Çµ", romaji: "sa" },
        { hiragana: "„Åó", katakana: "„Ç∑", romaji: "shi" },
        { hiragana: "„Åô", katakana: "„Çπ", romaji: "su" },
        { hiragana: "„Åõ", katakana: "„Çª", romaji: "se" },
        { hiragana: "„Åù", katakana: "„ÇΩ", romaji: "so" },
        { hiragana: "„Åü", katakana: "„Çø", romaji: "ta" },
        { hiragana: "„Å°", katakana: "„ÉÅ", romaji: "chi" },
        { hiragana: "„Å§", katakana: "„ÉÑ", romaji: "tsu" },
        { hiragana: "„Å¶", katakana: "„ÉÜ", romaji: "te" },
        { hiragana: "„Å®", katakana: "„Éà", romaji: "to" },
        { hiragana: "„Å™", katakana: "„Éä", romaji: "na" },
        { hiragana: "„Å´", katakana: "„Éã", romaji: "ni" },
        { hiragana: "„Å¨", katakana: "„Éå", romaji: "nu" },
        { hiragana: "„Å≠", katakana: "„Éç", romaji: "ne" },
        { hiragana: "„ÅÆ", katakana: "„Éé", romaji: "no" },
        { hiragana: "„ÅØ", katakana: "„Éè", romaji: "ha" },
        { hiragana: "„Å≤", katakana: "„Éí", romaji: "hi" },
        { hiragana: "„Åµ", katakana: "„Éï", romaji: "fu" },
        { hiragana: "„Å∏", katakana: "„Éò", romaji: "he" },
        { hiragana: "„Åª", katakana: "„Éõ", romaji: "ho" },
        { hiragana: "„Åæ", katakana: "„Éû", romaji: "ma" },
        { hiragana: "„Åø", katakana: "„Éü", romaji: "mi" },
        { hiragana: "„ÇÄ", katakana: "„É†", romaji: "mu" },
        { hiragana: "„ÇÅ", katakana: "„É°", romaji: "me" },
        { hiragana: "„ÇÇ", katakana: "„É¢", romaji: "mo" },
        { hiragana: "„ÇÑ", katakana: "„É§", romaji: "ya" },
        { hiragana: "„ÇÜ", katakana: "„É¶", romaji: "yu" },
        { hiragana: "„Çà", katakana: "„É®", romaji: "yo" },
        { hiragana: "„Çâ", katakana: "„É©", romaji: "ra" },
        { hiragana: "„Çä", katakana: "„É™", romaji: "ri" },
        { hiragana: "„Çã", katakana: "„É´", romaji: "ru" },
        { hiragana: "„Çå", katakana: "„É¨", romaji: "re" },
        { hiragana: "„Çç", katakana: "„É≠", romaji: "ro" },
        { hiragana: "„Çè", katakana: "„ÉØ", romaji: "wa" },
        { hiragana: "„Çí", katakana: "„É≤", romaji: "wo" },
        { hiragana: "„Çì", katakana: "„É≥", romaji: "n" },
      ];

      let board = [];
      let selectedTiles = [];
      let score = 0;
      let matches = 0;
      let totalMatches = 12;
      let isAnimating = false;
      let kanaPool = [];
      let level = 1;
      let timeElapsed = 0;
      let timerInterval = null;
      let isGameOver = false;
      let hasStarted = false;
      let isAutoMatching = false;
      let currentMatchStartTime = 0;
      let characterStats = {};
      let usedKanaIndices = new Set();
      let remainingKanaIndices = [];
      let boardCharacterCounts = {};

      function initGame() {
        board = [];
        selectedTiles = [];
        score = 0;
        matches = 0;
        isGameOver = false;
        hasStarted = false;
        timeElapsed = 0;
        currentMatchStartTime = 0;
        usedKanaIndices = new Set();
        remainingKanaIndices = [];
        boardCharacterCounts = {};

        // Clear any existing timer
        if (timerInterval) {
          clearInterval(timerInterval);
        }

        updateStats();
        updateProgress();
        updateNeededTypes();
        updateTimer();

        // Disable New Game button until timer starts
        const newGameBtn = document.getElementById("newGameBtn");
        if (newGameBtn) {
          newGameBtn.disabled = true;
        }

        // Initialize with all kana indices available
        remainingKanaIndices = Array.from({length: kanaMap.length}, (_, i) => i);
        
        // Shuffle remaining indices
        for (let i = remainingKanaIndices.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [remainingKanaIndices[i], remainingKanaIndices[j]] = [remainingKanaIndices[j], remainingKanaIndices[i]];
        }
        
        // Start with 12 kana for initial board
        const initialKanaCount = 12;
        kanaPool = [];
        for (let i = 0; i < initialKanaCount && remainingKanaIndices.length > 0; i++) {
          const kanaIndex = remainingKanaIndices.shift();
          usedKanaIndices.add(kanaIndex);
          kanaPool.push(kanaMap[kanaIndex]);
        }

        // Update total matches to be all 46 kana
        totalMatches = 46;
        updateStats();

        // Create tiles for the board
        const tiles = [];
        kanaPool.forEach((kana, index) => {
          // Find the original index of this kana in kanaMap
          const originalIndex = kanaMap.findIndex(
            (k) => k.hiragana === kana.hiragana,
          );

          tiles.push({
            kana,
            kanaIndex: originalIndex,
            type: "hiragana",
            display: kana.hiragana,
          });
          tiles.push({
            kana,
            kanaIndex: originalIndex,
            type: "katakana",
            display: kana.katakana,
          });
          tiles.push({
            kana,
            kanaIndex: originalIndex,
            type: "romaji",
            display: kana.romaji,
          });
        });

        // Shuffle tiles
        for (let i = tiles.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
        }

        // Fill the board
        let tileIndex = 0;
        for (let row = 0; row < 6; row++) {
          board[row] = [];
          for (let col = 0; col < 6; col++) {
            board[row][col] = tiles[tileIndex++];
          }
        }

        // Update board character counts
        updateBoardCharacterCounts();
        renderBoard();
      }

      function canCharacterMatch(kanaIndex) {
        // Check if all three types of this character are on the board
        const count = boardCharacterCounts[kanaIndex] || { hiragana: 0, katakana: 0, romaji: 0 };
        return count.hiragana > 0 && count.katakana > 0 && count.romaji > 0;
      }

      function updateBoardCharacterCounts() {
        // Reset counts
        boardCharacterCounts = {};
        
        // Count characters on board
        for (let row = 0; row < 6; row++) {
          for (let col = 0; col < 6; col++) {
            const tile = board[row][col];
            if (tile) {
              if (!boardCharacterCounts[tile.kanaIndex]) {
                boardCharacterCounts[tile.kanaIndex] = { hiragana: 0, katakana: 0, romaji: 0 };
              }
              boardCharacterCounts[tile.kanaIndex][tile.type]++;
            }
          }
        }
      }

      function renderBoard() {
        const gameBoard = document.getElementById("gameBoard");
        gameBoard.innerHTML = "";

        for (let row = 0; row < 6; row++) {
          for (let col = 0; col < 6; col++) {
            const tile = board[row][col];

            const tileElement = document.createElement("div");
            if (!tile) {
              tileElement.className = "tile empty";
            } else {
              // Check if this character can be matched (has all 3 types on board)
              const canMatch = canCharacterMatch(tile.kanaIndex);
              
              tileElement.className = `tile ${canMatch ? tile.type : 'unavailable'}`;
              tileElement.dataset.row = row;
              tileElement.dataset.col = col;
              tileElement.textContent = tile.display;
              
              if (canMatch) {
                // Add both click and touch events for mobile
                tileElement.addEventListener("click", (e) => {
                  e.preventDefault();
                  handleTileClick(row, col);
                });
                tileElement.addEventListener(
                  "touchstart",
                  (e) => {
                    e.preventDefault();
                    handleTileClick(row, col);
                  },
                  { passive: false },
                );
              }
            }

            gameBoard.appendChild(tileElement);
          }
        }

        updateFadedTiles();
      }

      function handleTileClick(row, col) {
        if (isAnimating || !board[row][col] || isGameOver || isAutoMatching)
          return;
          
        // Check if this character can be matched
        if (!canCharacterMatch(board[row][col].kanaIndex)) {
          return;
        }

        // Start timer on first interaction
        if (!hasStarted) {
          hasStarted = true;
          startTimer();
          currentMatchStartTime = Date.now();

          // Enable New Game button now that game has started
          const newGameBtn = document.getElementById("newGameBtn");
          if (newGameBtn) {
            newGameBtn.disabled = false;
          }
        }

        const clickedTile = { row, col };

        // Check if already selected
        const existingIndex = selectedTiles.findIndex(
          (t) => t.row === row && t.col === col,
        );

        if (existingIndex !== -1) {
          // Deselect
          selectedTiles.splice(existingIndex, 1);
          updateSelectedTiles();
          updateFadedTiles();
          updateNeededTypes();
          return;
        }

        // Check if this type is already selected
        const clickedType = board[row][col].type;
        const alreadyHasType = selectedTiles.some(
          (t) => board[t.row][t.col].type === clickedType,
        );

        if (alreadyHasType) {
          // Don't allow selecting same type twice
          return;
        }

        // If we already have 3 selected, this shouldn't happen
        if (selectedTiles.length >= 3) {
          return;
        }

        // Add to selection
        selectedTiles.push(clickedTile);
        updateSelectedTiles();
        updateFadedTiles();
        updateNeededTypes();

        // Check for early mismatch when second tile is selected
        if (selectedTiles.length === 2) {
          const tile1 = board[selectedTiles[0].row][selectedTiles[0].col];
          const tile2 = board[selectedTiles[1].row][selectedTiles[1].col];

          if (tile1.kanaIndex !== tile2.kanaIndex) {
            // Mismatch! Shake second tile but keep first selected
            handleMismatch(1);
            return;
          }
        }

        // Check if we have exactly 3 selected
        if (selectedTiles.length === 3) {
          checkMatch();
        }
      }

      function updateFadedTiles() {
        // Get selected types
        const selectedTypes = selectedTiles.map(
          ({ row, col }) => board[row][col].type,
        );

        // Update all tiles
        document.querySelectorAll(".tile").forEach((tile, index) => {
          const row = Math.floor(index / 6);
          const col = index % 6;

          if (!board[row][col] || tile.classList.contains("empty")) {
            return;
          }

          const tileType = board[row][col].type;
          const isSelected = selectedTiles.some(
            (t) => t.row === row && t.col === col,
          );
          const canMatch = canCharacterMatch(board[row][col].kanaIndex);

          if (!canMatch || (!isSelected && selectedTypes.includes(tileType))) {
            tile.classList.add("faded");
          } else {
            tile.classList.remove("faded");
          }
        });
      }

      function updateSelectedTiles() {
        // Clear all selections and lines
        document.querySelectorAll(".tile").forEach((tile) => {
          tile.classList.remove("selected");
        });
        document
          .querySelectorAll(".match-line")
          .forEach((line) => line.remove());

        // Highlight selected tiles
        selectedTiles.forEach(({ row, col }) => {
          const tile = document.querySelector(
            `[data-row="${row}"][data-col="${col}"]`,
          );
          if (tile) {
            tile.classList.add("selected");
          }
        });

        // Draw lines between selected tiles
        if (selectedTiles.length >= 2) {
          for (let i = 0; i < selectedTiles.length - 1; i++) {
            drawLine(selectedTiles[i], selectedTiles[i + 1]);
          }
          if (selectedTiles.length === 3) {
            drawLine(selectedTiles[2], selectedTiles[0]);
          }
        }
      }

      function updateNeededTypes() {
        const neededEl = document.getElementById("neededTypes");

        if (selectedTiles.length === 0) {
          neededEl.textContent =
            "Select 3 matching characters (one of each type)";
          return;
        }

        const selectedTypes = selectedTiles.map(
          ({ row, col }) => board[row][col].type,
        );
        const allTypes = ["hiragana", "katakana", "romaji"];
        const neededTypes = allTypes.filter(
          (type) => !selectedTypes.includes(type),
        );

        if (neededTypes.length > 0) {
          const typeNames = {
            hiragana: "Hiragana (pink)",
            katakana: "Katakana (blue)",
            romaji: "Romaji (green)",
          };
          neededEl.textContent = `Need: ${neededTypes
            .map((t) => typeNames[t])
            .join(" and ")}`;
        } else {
          neededEl.textContent = "Complete! All 3 types selected";
        }
      }

      function drawLine(tile1, tile2) {
        const boardEl = document.getElementById("gameBoard");
        const t1 = document.querySelector(
          `[data-row="${tile1.row}"][data-col="${tile1.col}"]`,
        );
        const t2 = document.querySelector(
          `[data-row="${tile2.row}"][data-col="${tile2.col}"]`,
        );

        if (!t1 || !t2) return;

        const rect1 = t1.getBoundingClientRect();
        const rect2 = t2.getBoundingClientRect();
        const boardRect = boardEl.getBoundingClientRect();

        const x1 = rect1.left + rect1.width / 2 - boardRect.left;
        const y1 = rect1.top + rect1.height / 2 - boardRect.top;
        const x2 = rect2.left + rect2.width / 2 - boardRect.left;
        const y2 = rect2.top + rect2.height / 2 - boardRect.top;

        const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        const angle = (Math.atan2(y2 - y1, x2 - x1) * 180) / Math.PI;

        const line = document.createElement("div");
        line.className = "match-line";
        line.style.width = length + "px";
        line.style.left = x1 + "px";
        line.style.top = y1 + "px";
        line.style.transform = `rotate(${angle}deg)`;

        boardEl.appendChild(line);
      }

      function handleMismatch(keepTiles = 0) {
        isAnimating = true;

        // Track incorrect attempts for these characters
        const tiles = selectedTiles.map(({ row, col }) => board[row][col]);
        tiles.forEach(tile => {
          if (tile) {
            const kanaIndex = tile.kanaIndex;
            if (!characterStats[kanaIndex]) {
              characterStats[kanaIndex] = {
                attempts: 0,
                incorrect: 0,
                totalTime: 0,
                avgTime: 0
              };
            }
            characterStats[kanaIndex].incorrect++;
          }
        });

        // Add red pulse to background
        document.body.classList.add("error-pulse");

        // Get tile elements and add shake animation (only shake the incorrect tiles)
        const tilesToShake = selectedTiles.slice(keepTiles);
        tilesToShake.forEach(({ row, col }) => {
          const tile = document.querySelector(
            `[data-row="${row}"][data-col="${col}"]`,
          );
          if (tile) {
            tile.classList.add("shake");
            // Show other writing systems for educational feedback
            showOtherWritingSystems(tile, board[row][col]);
          }
        });

        // Clear selection after shake animation
        setTimeout(() => {
          // Remove shake class
          document.querySelectorAll(".tile.shake").forEach((tile) => {
            tile.classList.remove("shake");
          });

          // Remove error pulse
          document.body.classList.remove("error-pulse");

          // Keep only the specified number of tiles
          selectedTiles = selectedTiles.slice(0, keepTiles);
          updateSelectedTiles();
          updateFadedTiles();
          updateNeededTypes();
          isAnimating = false;
        }, 500);
      }

      function checkMatch() {
        const tiles = selectedTiles.map(({ row, col }) => board[row][col]);

        // Check if all three tiles are from the same kana family
        const kanaIndex = tiles[0].kanaIndex;
        const allSameKana = tiles.every((t) => t.kanaIndex === kanaIndex);

        if (allSameKana) {
          // Valid match!
          processMatch();
        } else {
          // Invalid match - shake third tile but keep first two selected
          handleMismatch(2);
        }
      }

      function processMatch() {
        isAnimating = true;
        
        // Track response time for this match
        const responseTime = Date.now() - currentMatchStartTime;
        const tiles = selectedTiles.map(({ row, col }) => board[row][col]);
        const kanaIndex = tiles[0].kanaIndex;
        
        if (!characterStats[kanaIndex]) {
          characterStats[kanaIndex] = {
            attempts: 0,
            incorrect: 0,
            totalTime: 0,
            avgTime: 0
          };
        }
        
        characterStats[kanaIndex].attempts++;
        characterStats[kanaIndex].totalTime += responseTime;
        characterStats[kanaIndex].avgTime = Math.round(
          characterStats[kanaIndex].totalTime / characterStats[kanaIndex].attempts
        );
        
        matches++;
        score += 100;
        updateStats();
        updateProgress();

        // Get tile elements
        const tileElements = selectedTiles.map(({ row, col }) =>
          document.querySelector(`[data-row="${row}"][data-col="${col}"]`),
        );

        // Animate tiles
        tileElements.forEach((tile) => {
          if (tile) {
            tile.classList.add("match-animation");
            createParticles(tile);
          }
        });

        // Show combo text at center
        const centerX = selectedTiles.reduce((sum, t) => sum + t.col, 0) / 3;
        const centerY = selectedTiles.reduce((sum, t) => sum + t.row, 0) / 3;
        showCombo(centerX, centerY);

        setTimeout(() => {
          // Remove tiles from board
          selectedTiles.forEach(({ row, col }) => {
            board[row][col] = null;
          });

          // Clear selection
          selectedTiles = [];
          document
            .querySelectorAll(".match-line")
            .forEach((line) => line.remove());
          updateNeededTypes();

          // Add new tiles to empty spaces
          addNewTiles();
          
          // Update board character counts
          updateBoardCharacterCounts();
          
          // Re-render board
          renderBoard();
          
          // Reset match start time for next match
          currentMatchStartTime = Date.now();

          // Check for auto-match condition (only 3 tiles left)
          checkAutoMatch();

          // Check if all 46 kana have been matched
          if (matches === totalMatches) {
            setTimeout(() => {
              gameOver();
            }, 500);
          }

          isAnimating = false;
          isAutoMatching = false;
        }, 600);
      }

      function createParticles(tileElement) {
        const rect = tileElement.getBoundingClientRect();
        const boardRect = document
          .getElementById("gameBoard")
          .getBoundingClientRect();
        const x = rect.left + rect.width / 2 - boardRect.left;
        const y = rect.top + rect.height / 2 - boardRect.top;

        const emojis = ["‚ú®", "‚≠ê", "üåü"];

        for (let i = 0; i < 6; i++) {
          const particle = document.createElement("div");
          particle.className = "particle";
          particle.textContent =
            emojis[Math.floor(Math.random() * emojis.length)];
          particle.style.left = x + "px";
          particle.style.top = y + "px";
          particle.style.setProperty(
            "--dx",
            (Math.random() - 0.5) * 150 + "px",
          );
          particle.style.setProperty(
            "--dy",
            (Math.random() - 0.5) * 150 + "px",
          );

          document.getElementById("gameBoard").appendChild(particle);
          setTimeout(() => particle.remove(), 1000);
        }
      }

      function showCombo(gridX, gridY) {
        const boardEl = document.getElementById("gameBoard");
        const x = (gridX + 0.5) * 93 + 20; // 85px tile + 8px gap
        const y = (gridY + 0.5) * 93 + 20;

        const combo = document.createElement("div");
        combo.className = "combo-text";
        combo.textContent = "MATCH!";
        combo.style.left = x + "px";
        combo.style.top = y + "px";

        boardEl.appendChild(combo);
        setTimeout(() => combo.remove(), 1500);
      }

      function checkAutoMatch() {
        // Count remaining tiles
        let remainingTiles = [];
        for (let row = 0; row < 6; row++) {
          for (let col = 0; col < 6; col++) {
            if (board[row][col]) {
              remainingTiles.push({ row, col, tile: board[row][col] });
            }
          }
        }

        // If exactly 3 tiles remain, auto-match them
        if (remainingTiles.length === 3) {
          // Verify they're from the same kana family (they should be)
          const kanaIndex = remainingTiles[0].tile.kanaIndex;
          const allSame = remainingTiles.every(
            (t) => t.tile.kanaIndex === kanaIndex,
          );

          if (allSame) {
            setTimeout(() => performAutoMatch(remainingTiles), 300);
          }
        }
      }

      function performAutoMatch(tiles) {
        isAnimating = true;
        isAutoMatching = true;

        // Don't pause timer during auto-match in stopwatch mode
        // Just mark that we're auto-matching
        isAutoMatching = true;

        // Sort tiles to ensure consistent order: hiragana, katakana, romaji
        const typeOrder = { hiragana: 0, katakana: 1, romaji: 2 };
        tiles.sort((a, b) => typeOrder[a.tile.type] - typeOrder[b.tile.type]);

        // Animate selection of each tile with delay
        tiles.forEach((tileData, index) => {
          setTimeout(() => {
            selectedTiles.push({ row: tileData.row, col: tileData.col });
            updateSelectedTiles();
            updateFadedTiles();
            updateNeededTypes();

            // After all three are selected, process the match
            if (index === 2) {
              setTimeout(() => {
                checkMatch();
                // Resume timer after match is processed (will happen in processMatch)
              }, 400);
            }
          }, index * 250); // 250ms delay between each selection
        });
      }

      function showHint() {
        if (isAnimating) return;

        // Clear current selection first
        selectedTiles = [];
        updateSelectedTiles();
        updateFadedTiles();
        updateNeededTypes();

        // Find an unmatched set
        const groups = {};

        for (let row = 0; row < 6; row++) {
          for (let col = 0; col < 6; col++) {
            const tile = board[row][col];
            if (!tile) continue;

            if (!groups[tile.kanaIndex]) {
              groups[tile.kanaIndex] = [];
            }
            groups[tile.kanaIndex].push({ row, col, type: tile.type });
          }
        }

        // Find first complete set
        for (let kanaIndex in groups) {
          const tiles = groups[kanaIndex];
          const types = {};

          tiles.forEach((t) => {
            if (!types[t.type]) types[t.type] = t;
          });

          if (types.hiragana && types.katakana && types.romaji) {
            // Highlight these tiles
            [types.hiragana, types.katakana, types.romaji].forEach((t) => {
              const tile = document.querySelector(
                `[data-row="${t.row}"][data-col="${t.col}"]`,
              );
              if (tile) {
                tile.style.animation = "none";
                setTimeout(() => {
                  tile.style.boxShadow = "0 0 30px #ffd700";
                  tile.style.transform = "scale(1.1)";
                }, 10);
                setTimeout(() => {
                  tile.style.boxShadow = "";
                  tile.style.transform = "";
                }, 2000);
              }
            });
            break;
          }
        }
      }

      function showMessage(text) {
        const msg = document.getElementById("message");
        msg.textContent = text;
        msg.classList.add("show");

        setTimeout(() => {
          msg.classList.remove("show");
        }, 2000);
      }

      function updateStats() {
        document.getElementById("score").textContent = score;
        document.getElementById("matches").textContent = matches;
        document.getElementById("totalMatches").textContent = totalMatches;
      }

      function updateProgress() {
        const percentage = (matches / totalMatches) * 100;
        document.getElementById("progressFill").style.width = percentage + "%";
      }

      function startTimer() {
        timerInterval = setInterval(() => {
          if (isGameOver) return;

          timeElapsed++;
          updateTimer();
        }, 1000);
      }

      function updateTimer() {
        const timerEl = document.getElementById("timer");
        
        if (timeElapsed < 60) {
          timerEl.textContent = timeElapsed + "s";
        } else {
          const minutes = Math.floor(timeElapsed / 60);
          const seconds = timeElapsed % 60;
          timerEl.textContent = minutes + "m" + seconds + "s";
        }
      }

      function gameOver() {
        isGameOver = true;
        clearInterval(timerInterval);

        // Disable all tiles
        document.querySelectorAll(".tile").forEach((tile) => {
          tile.style.pointerEvents = "none";
          tile.style.opacity = "0.5";
        });

        showMessage("Level Complete!");

        // Show character statistics
        setTimeout(() => {
          showCharacterStats();
        }, 2000);
      }

      function showCharacterStats() {
        let statsMessage = "Character Performance:\n\n";
        
        // Sort characters by difficulty (incorrect attempts + avg time)
        const sortedStats = Object.entries(characterStats)
          .filter(([_, stats]) => stats.attempts > 0)
          .sort((a, b) => {
            const difficultyA = a[1].incorrect + (a[1].avgTime / 1000);
            const difficultyB = b[1].incorrect + (b[1].avgTime / 1000);
            return difficultyB - difficultyA;
          })
          .slice(0, 5); // Show top 5 most difficult
        
        if (sortedStats.length > 0) {
          statsMessage += "Most Challenging Characters:\n";
          sortedStats.forEach(([kanaIndex, stats]) => {
            const kana = kanaMap[kanaIndex];
            const accuracy = Math.round(((stats.attempts - stats.incorrect) / stats.attempts) * 100);
            statsMessage += `${kana.hiragana}/${kana.katakana}/${kana.romaji}: `;
            statsMessage += `${stats.avgTime / 1000}s avg, ${accuracy}% accuracy\n`;
          });
        }
        
        statsMessage += `\nTotal time: ${timeElapsed}s\nScore: ${score}`;
        statsMessage += "\n\nPlay again?";
        
        if (confirm(statsMessage)) {
          level = 1;
          initGame();
        }
      }

      // Initialize the game
      initGame();
      
      // Debug: Press 'd' to toggle character stats display
      document.addEventListener('keydown', (e) => {
        if (e.key === 'd') {
          const debugEl = document.getElementById('charStatsDebug');
          if (debugEl.style.display === 'none') {
            debugEl.style.display = 'block';
            updateDebugStats();
          } else {
            debugEl.style.display = 'none';
          }
        }
      });
      
      function updateDebugStats() {
        const debugEl = document.getElementById('charStatsDebug');
        if (!debugEl || debugEl.style.display === 'none') return;
        
        let html = '<h3>Character Statistics</h3>';
        const sortedStats = Object.entries(characterStats)
          .filter(([_, stats]) => stats.attempts > 0)
          .sort((a, b) => b[1].avgTime - a[1].avgTime);
        
        if (sortedStats.length === 0) {
          html += '<p>No data yet - start matching!</p>';
        } else {
          html += '<table style="width:100%; text-align:left;">';
          html += '<tr><th>Character</th><th>Avg Time</th><th>Attempts</th><th>Errors</th><th>Accuracy</th></tr>';
          
          sortedStats.forEach(([kanaIndex, stats]) => {
            const kana = kanaMap[kanaIndex];
            const accuracy = Math.round(((stats.attempts - stats.incorrect) / stats.attempts) * 100);
            html += '<tr>';
            html += `<td>${kana.hiragana}/${kana.katakana}/${kana.romaji}</td>`;
            html += `<td>${(stats.avgTime / 1000).toFixed(1)}s</td>`;
            html += `<td>${stats.attempts}</td>`;
            html += `<td>${stats.incorrect}</td>`;
            html += `<td>${accuracy}%</td>`;
            html += '</tr>';
          });
          html += '</table>';
        }
        
        debugEl.innerHTML = html;
      }
      
      // Update debug stats periodically if visible
      setInterval(updateDebugStats, 1000);
      
      function showOtherWritingSystems(tileElement, tileData) {
        const kana = tileData.kana;
        const originalType = tileData.type;
        const rect = tileElement.getBoundingClientRect();
        const boardRect = document.getElementById('gameBoard').getBoundingClientRect();
        
        // Get the other two writing systems
        const otherTypes = [];
        if (originalType !== 'hiragana') {
          otherTypes.push({ display: kana.hiragana, type: 'hiragana', direction: 'up' });
        }
        if (originalType !== 'katakana') {
          otherTypes.push({ display: kana.katakana, type: 'katakana', direction: otherTypes.length === 0 ? 'up' : 'down' });
        }
        if (originalType !== 'romaji') {
          otherTypes.push({ display: kana.romaji, type: 'romaji', direction: otherTypes.length === 0 ? 'up' : 'down' });
        }
        
        // Create floating spirit elements
        otherTypes.forEach((item, index) => {
          const spirit = document.createElement('div');
          spirit.className = `spirit-text ${item.type} float-${item.direction}`;
          spirit.textContent = item.display;
          
          // Position at the center of the tile
          const x = rect.left + rect.width / 2 - boardRect.left;
          const y = rect.top + rect.height / 2 - boardRect.top;
          spirit.style.left = x + 'px';
          spirit.style.top = y + 'px';
          
          document.getElementById('gameBoard').appendChild(spirit);
          
          // Remove after animation
          setTimeout(() => spirit.remove(), 1500);
        });
      }
      
      function addNewTiles() {
        // Find empty positions
        const emptyPositions = [];
        for (let row = 0; row < 6; row++) {
          for (let col = 0; col < 6; col++) {
            if (!board[row][col]) {
              emptyPositions.push({ row, col });
            }
          }
        }
        
        if (emptyPositions.length === 0) {
          return;
        }
        
        // Get kana indices that are currently on the board
        const kanaOnBoard = new Set();
        for (let row = 0; row < 6; row++) {
          for (let col = 0; col < 6; col++) {
            if (board[row][col]) {
              kanaOnBoard.add(board[row][col].kanaIndex);
            }
          }
        }
        
        // Shuffle empty positions
        for (let i = emptyPositions.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [emptyPositions[i], emptyPositions[j]] = [emptyPositions[j], emptyPositions[i]];
        }
        
        // First, check if we need to complete any partial sets that are already on board
        const partialSets = [];
        for (const [kanaIndex, counts] of Object.entries(boardCharacterCounts)) {
          const total = counts.hiragana + counts.katakana + counts.romaji;
          if (total > 0 && total < 3) {
            // This is a partial set
            const missingTypes = [];
            if (counts.hiragana === 0) missingTypes.push('hiragana');
            if (counts.katakana === 0) missingTypes.push('katakana');
            if (counts.romaji === 0) missingTypes.push('romaji');
            partialSets.push({ kanaIndex: parseInt(kanaIndex), missingTypes });
          }
        }
        
        // Randomly complete some partial sets (not all at once)
        if (partialSets.length > 0 && Math.random() < 0.7) { // 70% chance to complete partial sets
          const setsToComplete = Math.min(Math.floor(Math.random() * 2) + 1, partialSets.length);
          const shuffledPartials = [...partialSets];
          // Shuffle partial sets
          for (let i = shuffledPartials.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffledPartials[i], shuffledPartials[j]] = [shuffledPartials[j], shuffledPartials[i]];
          }
          
          for (let i = 0; i < setsToComplete && emptyPositions.length > 0; i++) {
            const partial = shuffledPartials[i];
            const kana = kanaMap[partial.kanaIndex];
            
            for (const type of partial.missingTypes) {
              if (emptyPositions.length > 0) {
                const pos = emptyPositions.shift();
                board[pos.row][pos.col] = {
                  kana,
                  kanaIndex: partial.kanaIndex,
                  type,
                  display: kana[type]
                };
              }
            }
          }
        }
        
        // Then add new partial sets (only if we have remaining kana that aren't on board)
        const availableIndices = remainingKanaIndices.filter(idx => !kanaOnBoard.has(idx));
        
        while (emptyPositions.length > 0 && availableIndices.length > 0) {
          const idx = Math.floor(Math.random() * availableIndices.length);
          const kanaIndex = availableIndices.splice(idx, 1)[0];
          // Remove from remainingKanaIndices as well
          const remainingIdx = remainingKanaIndices.indexOf(kanaIndex);
          if (remainingIdx !== -1) {
            remainingKanaIndices.splice(remainingIdx, 1);
          }
          
          usedKanaIndices.add(kanaIndex);
          const kana = kanaMap[kanaIndex];
          
          // Randomly decide how many tiles to add (1-2)
          const tilesToAdd = Math.random() < 0.5 ? 1 : 2;
          
          // Randomly select which types to add
          const types = ['hiragana', 'katakana', 'romaji'];
          const shuffledTypes = [...types];
          for (let i = shuffledTypes.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffledTypes[i], shuffledTypes[j]] = [shuffledTypes[j], shuffledTypes[i]];
          }
          
          // Add the tiles
          for (let i = 0; i < tilesToAdd && emptyPositions.length > 0; i++) {
            const pos = emptyPositions.shift();
            const type = shuffledTypes[i];
            board[pos.row][pos.col] = {
              kana,
              kanaIndex,
              type,
              display: kana[type]
            };
          }
          
          // If we've filled all positions, stop
          if (emptyPositions.length === 0) {
            break;
          }
        }
      }

      // Prevent pull-to-refresh and overscroll on mobile
      document.addEventListener(
        "touchmove",
        function (e) {
          e.preventDefault();
        },
        { passive: false },
      );

      // Prevent double-tap zoom
      let lastTouchEnd = 0;
      document.addEventListener(
        "touchend",
        function (e) {
          const now = Date.now();
          if (now - lastTouchEnd <= 300) {
            e.preventDefault();
          }
          lastTouchEnd = now;
        },
        false,
      );
    </script>
  </body>
</html>
