<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="mobile-web-app-capable" content="yes" />
    <title>Matcha3!</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@500;700;900&display=swap");

      * {
        box-sizing: border-box;
      }

      html {
        height: 100%;
        background: #667eea;
      }

      body {
        margin: 0;
        padding: 0;
        font-family:
          "Noto Sans JP",
          -apple-system,
          sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        background-attachment: fixed;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        color: #fff;
      }

      .game-container {
        text-align: center;
        padding: 20px;
      }

      h1 {
        margin: 0 0 30px 0;
        font-size: 3em;
        font-weight: 900;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
      }

      .stats {
        display: flex;
        justify-content: center;
        margin-bottom: 20px;
        gap: 20px;
      }

      .stat {
        background: rgba(255, 255, 255, 0.15);
        padding: 15px 30px;
        border-radius: 20px;
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255, 255, 255, 0.3);
        font-size: 1.1em;
      }

      .stat span {
        font-weight: bold;
        font-size: 1.3em;
        color: #ffd700;
      }

      .stat.timer.penalty span {
        color: #ff6b6b;
        animation: pulse 0.5s ease;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      .game-board {
        display: inline-grid;
        grid-template-columns: repeat(6, 85px);
        grid-template-rows: repeat(6, 85px);
        gap: 8px;
        background: rgba(0, 0, 0, 0.3);
        padding: 20px;
        border-radius: 20px;
        position: relative;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      }

      .tile {
        width: 85px;
        height: 85px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        user-select: none;
        border-radius: 12px;
        border: 3px solid transparent;
        font-size: 2em;
        font-weight: 700;
        color: #333;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      /* Simple color coding for each script type */
      .tile.hiragana {
        background: #ffb6c1;
        border-color: #ff69b4;
      }

      .tile.katakana {
        background: #87ceeb;
        border-color: #4682b4;
      }

      .tile.romaji {
        background: #90ee90;
        border-color: #32cd32;
      }

      /* Faded state for tiles of same type */
      .tile.faded {
        opacity: 0.15;
        transform: scale(0.9);
        cursor: not-allowed;
        filter: grayscale(50%);
      }

      .tile.empty {
        background: transparent;
        border: none;
        box-shadow: none;
        cursor: default;
        pointer-events: none;
      }

      .tile:not(.faded):not(.empty):hover {
        transform: translateY(-3px) scale(1.05);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      }

      .tile.selected {
        transform: scale(1.1);
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        border-color: #ffd700 !important;
        border-width: 4px;
      }

      .tile.match-animation {
        animation: matchDisappear 0.6s ease forwards;
      }

      @keyframes matchDisappear {
        0% {
          transform: scale(1) rotate(0deg);
          opacity: 1;
        }
        50% {
          transform: scale(1.3) rotate(180deg);
        }
        100% {
          transform: scale(0) rotate(360deg);
          opacity: 0;
        }
      }

      .tile.shake {
        animation: shake 0.5s ease;
      }

      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        10%,
        30%,
        50%,
        70%,
        90% {
          transform: translateX(-8px);
        }
        20%,
        40%,
        60%,
        80% {
          transform: translateX(8px);
        }
      }

      .error-pulse {
        animation: errorPulse 0.5s ease;
      }

      @keyframes errorPulse {
        0%,
        100% {
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        50% {
          background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
        }
      }

      .match-line {
        position: absolute;
        height: 3px;
        background: #ffd700;
        transform-origin: left center;
        pointer-events: none;
        z-index: 10;
        border-radius: 2px;
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        opacity: 0.8;
      }

      .combo-text {
        position: absolute;
        font-size: 2.5em;
        font-weight: 900;
        animation: comboFloat 1.5s ease-out forwards;
        pointer-events: none;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
        color: #ffd700;
        z-index: 100;
      }

      @keyframes comboFloat {
        0% {
          transform: translate(-50%, -50%) scale(0);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -120px) scale(1.5);
          opacity: 0;
        }
      }

      button {
        background: linear-gradient(135deg, #ffd700, #ffed4e);
        color: #333;
        border: none;
        padding: 15px 35px;
        font-size: 1.2em;
        font-weight: bold;
        border-radius: 30px;
        cursor: pointer;
        margin: 10px 5px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
      }

      button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(255, 215, 0, 0.5);
      }

      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .legend {
        margin-top: 30px;
        display: flex;
        justify-content: center;
        gap: 40px;
        background: rgba(255, 255, 255, 0.1);
        padding: 15px 30px;
        border-radius: 20px;
        backdrop-filter: blur(10px);
        transform: scale(0.75);
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 1.1em;
      }

      .legend-box {
        width: 30px;
        height: 30px;
        border-radius: 6px;
        border: 2px solid;
      }

      .legend-box.hiragana {
        background: #ffb6c1;
        border-color: #ff69b4;
      }

      .legend-box.katakana {
        background: #87ceeb;
        border-color: #4682b4;
      }

      .legend-box.romaji {
        background: #90ee90;
        border-color: #32cd32;
      }

      .message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: #fff;
        padding: 30px 50px;
        border-radius: 20px;
        font-size: 2em;
        font-weight: bold;
        z-index: 1000;
        display: none;
      }

      .message.show {
        display: block;
        animation: messagePopup 2s ease forwards;
      }

      @keyframes messagePopup {
        0% {
          transform: translate(-50%, -50%) scale(0);
          opacity: 0;
        }
        20% {
          transform: translate(-50%, -50%) scale(1.1);
          opacity: 1;
        }
        80% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 0;
        }
      }

      .particle {
        position: absolute;
        pointer-events: none;
        font-size: 2em;
        animation: particle 1s ease-out forwards;
        z-index: 50;
      }

      @keyframes particle {
        0% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
        100% {
          transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy)))
            scale(0);
          opacity: 0;
        }
      }

      .progress-bar {
        margin: 10px auto 5px;
        width: 580px; /* Same as game board */
        height: 6px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 3px;
        overflow: hidden;
        position: relative;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #ffd700, #ffed4e);
        width: 0%;
        transition: width 0.5s ease;
        border-radius: 3px;
      }


      .needed-types {
        margin: 10px 0;
        font-size: 1.2em;
        min-height: 30px;
        color: #ffd700;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      /* Mobile Responsive Styles */
      @media (max-width: 768px) {
        body {
          padding: 5px;
        }

        .game-container {
          padding: 5px;
          width: 100%;
          max-width: 100vw;
        }

        h1 {
          font-size: 2em;
          margin: 0 0 15px 0;
        }

        .stats {
          flex-wrap: wrap;
          gap: 10px;
          margin-bottom: 10px;
        }

        .stat {
          padding: 10px 15px;
          font-size: 0.9em;
          flex: 1;
          min-width: calc(33% - 10px);
        }

        .stat span {
          font-size: 1.1em;
        }

        .needed-types {
          font-size: 1em;
          margin: 5px 0;
        }

        /* Calculate tile size based on viewport width */
        .game-board {
          width: calc(100vw - 20px);
          max-width: 420px;
          height: calc(100vw - 20px);
          max-height: 420px;
          padding: 10px;
          gap: 4px;
          grid-template-columns: repeat(6, 1fr);
          grid-template-rows: repeat(6, 1fr);
        }

        .tile {
          width: 100%;
          height: 100%;
          font-size: 1.5em;
          border-radius: 8px;
          border-width: 2px;
        }

        .progress-bar {
          width: calc(100vw - 20px);
          max-width: 420px;
          height: 5px;
          margin: 5px auto 15px;
        }

        button {
          padding: 14px 30px;
          font-size: 1.1em;
          margin: 5px;
          -webkit-tap-highlight-color: transparent;
          touch-action: manipulation;
        }

        .legend {
          gap: 20px;
          padding: 10px 15px;
          transform: scale(1);
          margin-top: 15px;
          flex-wrap: wrap;
        }

        .legend-item {
          font-size: 0.9em;
          gap: 5px;
        }

        .legend-box {
          width: 20px;
          height: 20px;
        }

        .message {
          font-size: 1.5em;
          padding: 20px 30px;
          width: 90%;
          max-width: 300px;
        }

        .combo-text {
          font-size: 1.8em;
        }

        .particle {
          font-size: 1.5em;
        }

        /* Prevent text selection on mobile */
        * {
          -webkit-user-select: none;
          -webkit-touch-callout: none;
          user-select: none;
        }

        /* Ensure full height on mobile */
        html,
        body {
          height: 100%;
          min-height: 100vh;
          overflow: hidden;
          position: fixed;
          width: 100%;
        }

        /* Ensure gradient background is applied */
        body {
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          background-attachment: fixed;
        }
      }

      /* Very small phones */
      @media (max-width: 360px) {
        h1 {
          font-size: 1.5em;
        }

        .stat {
          font-size: 0.8em;
          padding: 8px 12px;
        }

        .game-board {
          width: calc(100vw - 15px);
          height: calc(100vw - 15px);
        }

        .tile {
          font-size: 1.2em;
        }

        button {
          font-size: 1em;
          padding: 12px 24px;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <h1>Matcha3! 🍵</h1>
      <div class="stats">
        <div class="stat">Score: <span id="score">0</span></div>
        <div class="stat">
          Matches: <span id="matches">0</span> /
          <span id="totalMatches">12</span>
        </div>
        <div class="stat timer">Time: <span id="timer">0</span>s</div>
      </div>
      <div class="needed-types" id="neededTypes"></div>
      <div class="game-board" id="gameBoard"></div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div id="charStatsDebug" style="display: none; color: white; margin-top: 20px; font-size: 0.9em;"></div>
      <div>
        <button onclick="initGame()" id="newGameBtn">New Game</button>
        <button onclick="showHint()" id="hintBtn">Show Hint</button>
      </div>
      <div class="legend">
        <div class="legend-item">
          <div class="legend-box hiragana"></div>
          <span>Hiragana (ひらがな)</span>
        </div>
        <div class="legend-item">
          <div class="legend-box katakana"></div>
          <span>Katakana (カタカナ)</span>
        </div>
        <div class="legend-item">
          <div class="legend-box romaji"></div>
          <span>Romaji (ABC)</span>
        </div>
      </div>
    </div>

    <div class="message" id="message"></div>

    <script>
      const kanaMap = [
        { hiragana: "あ", katakana: "ア", romaji: "a" },
        { hiragana: "い", katakana: "イ", romaji: "i" },
        { hiragana: "う", katakana: "ウ", romaji: "u" },
        { hiragana: "え", katakana: "エ", romaji: "e" },
        { hiragana: "お", katakana: "オ", romaji: "o" },
        { hiragana: "か", katakana: "カ", romaji: "ka" },
        { hiragana: "き", katakana: "キ", romaji: "ki" },
        { hiragana: "く", katakana: "ク", romaji: "ku" },
        { hiragana: "け", katakana: "ケ", romaji: "ke" },
        { hiragana: "こ", katakana: "コ", romaji: "ko" },
        { hiragana: "さ", katakana: "サ", romaji: "sa" },
        { hiragana: "し", katakana: "シ", romaji: "shi" },
        { hiragana: "す", katakana: "ス", romaji: "su" },
        { hiragana: "せ", katakana: "セ", romaji: "se" },
        { hiragana: "そ", katakana: "ソ", romaji: "so" },
        { hiragana: "た", katakana: "タ", romaji: "ta" },
        { hiragana: "ち", katakana: "チ", romaji: "chi" },
        { hiragana: "つ", katakana: "ツ", romaji: "tsu" },
        { hiragana: "て", katakana: "テ", romaji: "te" },
        { hiragana: "と", katakana: "ト", romaji: "to" },
        { hiragana: "な", katakana: "ナ", romaji: "na" },
        { hiragana: "に", katakana: "ニ", romaji: "ni" },
        { hiragana: "ぬ", katakana: "ヌ", romaji: "nu" },
        { hiragana: "ね", katakana: "ネ", romaji: "ne" },
        { hiragana: "の", katakana: "ノ", romaji: "no" },
        { hiragana: "は", katakana: "ハ", romaji: "ha" },
        { hiragana: "ひ", katakana: "ヒ", romaji: "hi" },
        { hiragana: "ふ", katakana: "フ", romaji: "fu" },
        { hiragana: "へ", katakana: "ヘ", romaji: "he" },
        { hiragana: "ほ", katakana: "ホ", romaji: "ho" },
        { hiragana: "ま", katakana: "マ", romaji: "ma" },
        { hiragana: "み", katakana: "ミ", romaji: "mi" },
        { hiragana: "む", katakana: "ム", romaji: "mu" },
        { hiragana: "め", katakana: "メ", romaji: "me" },
        { hiragana: "も", katakana: "モ", romaji: "mo" },
        { hiragana: "や", katakana: "ヤ", romaji: "ya" },
        { hiragana: "ゆ", katakana: "ユ", romaji: "yu" },
        { hiragana: "よ", katakana: "ヨ", romaji: "yo" },
        { hiragana: "ら", katakana: "ラ", romaji: "ra" },
        { hiragana: "り", katakana: "リ", romaji: "ri" },
        { hiragana: "る", katakana: "ル", romaji: "ru" },
        { hiragana: "れ", katakana: "レ", romaji: "re" },
        { hiragana: "ろ", katakana: "ロ", romaji: "ro" },
        { hiragana: "わ", katakana: "ワ", romaji: "wa" },
        { hiragana: "を", katakana: "ヲ", romaji: "wo" },
        { hiragana: "ん", katakana: "ン", romaji: "n" },
      ];

      let board = [];
      let selectedTiles = [];
      let score = 0;
      let matches = 0;
      let totalMatches = 12;
      let isAnimating = false;
      let kanaPool = [];
      let level = 1;
      let timeElapsed = 0;
      let timerInterval = null;
      let isGameOver = false;
      let hasStarted = false;
      let isAutoMatching = false;
      let currentMatchStartTime = 0;
      let characterStats = {};

      function initGame() {
        board = [];
        selectedTiles = [];
        score = 0;
        matches = 0;
        isGameOver = false;
        hasStarted = false;
        timeElapsed = 0;
        currentMatchStartTime = 0;

        // Clear any existing timer
        if (timerInterval) {
          clearInterval(timerInterval);
        }

        updateStats();
        updateProgress();
        updateNeededTypes();
        updateTimer();

        // Disable New Game button until timer starts
        const newGameBtn = document.getElementById("newGameBtn");
        if (newGameBtn) {
          newGameBtn.disabled = true;
        }

        // Select random kana for this level
        // Create array of all indices
        const allIndices = Array.from({length: kanaMap.length}, (_, i) => i);
        
        // Shuffle all indices
        for (let i = allIndices.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [allIndices[i], allIndices[j]] = [allIndices[j], allIndices[i]];
        }
        
        // Take 12 random kana
        kanaPool = allIndices.slice(0, 12).map(i => kanaMap[i]);

        // Update total matches based on actual kana pool size
        totalMatches = kanaPool.length;
        updateStats();

        // Create tiles for the board
        const tiles = [];
        kanaPool.forEach((kana, index) => {
          // Find the original index of this kana in kanaMap
          const originalIndex = kanaMap.findIndex(
            (k) => k.hiragana === kana.hiragana,
          );

          tiles.push({
            kana,
            kanaIndex: originalIndex,
            type: "hiragana",
            display: kana.hiragana,
          });
          tiles.push({
            kana,
            kanaIndex: originalIndex,
            type: "katakana",
            display: kana.katakana,
          });
          tiles.push({
            kana,
            kanaIndex: originalIndex,
            type: "romaji",
            display: kana.romaji,
          });
        });

        // Shuffle tiles
        for (let i = tiles.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
        }

        // Fill the board
        let tileIndex = 0;
        for (let row = 0; row < 6; row++) {
          board[row] = [];
          for (let col = 0; col < 6; col++) {
            board[row][col] = tiles[tileIndex++];
          }
        }

        renderBoard();
      }

      function renderBoard() {
        const gameBoard = document.getElementById("gameBoard");
        gameBoard.innerHTML = "";

        for (let row = 0; row < 6; row++) {
          for (let col = 0; col < 6; col++) {
            const tile = board[row][col];

            const tileElement = document.createElement("div");
            if (!tile) {
              tileElement.className = "tile empty";
            } else {
              tileElement.className = `tile ${tile.type}`;
              tileElement.dataset.row = row;
              tileElement.dataset.col = col;
              tileElement.textContent = tile.display;
              // Add both click and touch events for mobile
              tileElement.addEventListener("click", (e) => {
                e.preventDefault();
                handleTileClick(row, col);
              });
              tileElement.addEventListener(
                "touchstart",
                (e) => {
                  e.preventDefault();
                  handleTileClick(row, col);
                },
                { passive: false },
              );
            }

            gameBoard.appendChild(tileElement);
          }
        }

        updateFadedTiles();
      }

      function handleTileClick(row, col) {
        if (isAnimating || !board[row][col] || isGameOver || isAutoMatching)
          return;

        // Start timer on first interaction
        if (!hasStarted) {
          hasStarted = true;
          startTimer();
          currentMatchStartTime = Date.now();

          // Enable New Game button now that game has started
          const newGameBtn = document.getElementById("newGameBtn");
          if (newGameBtn) {
            newGameBtn.disabled = false;
          }
        }

        const clickedTile = { row, col };

        // Check if already selected
        const existingIndex = selectedTiles.findIndex(
          (t) => t.row === row && t.col === col,
        );

        if (existingIndex !== -1) {
          // Deselect
          selectedTiles.splice(existingIndex, 1);
          updateSelectedTiles();
          updateFadedTiles();
          updateNeededTypes();
          return;
        }

        // Check if this type is already selected
        const clickedType = board[row][col].type;
        const alreadyHasType = selectedTiles.some(
          (t) => board[t.row][t.col].type === clickedType,
        );

        if (alreadyHasType) {
          // Don't allow selecting same type twice
          return;
        }

        // If we already have 3 selected, this shouldn't happen
        if (selectedTiles.length >= 3) {
          return;
        }

        // Add to selection
        selectedTiles.push(clickedTile);
        updateSelectedTiles();
        updateFadedTiles();
        updateNeededTypes();

        // Check for early mismatch when second tile is selected
        if (selectedTiles.length === 2) {
          const tile1 = board[selectedTiles[0].row][selectedTiles[0].col];
          const tile2 = board[selectedTiles[1].row][selectedTiles[1].col];

          if (tile1.kanaIndex !== tile2.kanaIndex) {
            // Mismatch! Shake both tiles and clear selection
            handleMismatch();
            return;
          }
        }

        // Check if we have exactly 3 selected
        if (selectedTiles.length === 3) {
          checkMatch();
        }
      }

      function updateFadedTiles() {
        // Get selected types
        const selectedTypes = selectedTiles.map(
          ({ row, col }) => board[row][col].type,
        );

        // Update all tiles
        document.querySelectorAll(".tile").forEach((tile, index) => {
          const row = Math.floor(index / 6);
          const col = index % 6;

          if (!board[row][col] || tile.classList.contains("empty")) {
            return;
          }

          const tileType = board[row][col].type;
          const isSelected = selectedTiles.some(
            (t) => t.row === row && t.col === col,
          );

          if (!isSelected && selectedTypes.includes(tileType)) {
            tile.classList.add("faded");
          } else {
            tile.classList.remove("faded");
          }
        });
      }

      function updateSelectedTiles() {
        // Clear all selections and lines
        document.querySelectorAll(".tile").forEach((tile) => {
          tile.classList.remove("selected");
        });
        document
          .querySelectorAll(".match-line")
          .forEach((line) => line.remove());

        // Highlight selected tiles
        selectedTiles.forEach(({ row, col }) => {
          const tile = document.querySelector(
            `[data-row="${row}"][data-col="${col}"]`,
          );
          if (tile) {
            tile.classList.add("selected");
          }
        });

        // Draw lines between selected tiles
        if (selectedTiles.length >= 2) {
          for (let i = 0; i < selectedTiles.length - 1; i++) {
            drawLine(selectedTiles[i], selectedTiles[i + 1]);
          }
          if (selectedTiles.length === 3) {
            drawLine(selectedTiles[2], selectedTiles[0]);
          }
        }
      }

      function updateNeededTypes() {
        const neededEl = document.getElementById("neededTypes");

        if (selectedTiles.length === 0) {
          neededEl.textContent =
            "Select 3 matching characters (one of each type)";
          return;
        }

        const selectedTypes = selectedTiles.map(
          ({ row, col }) => board[row][col].type,
        );
        const allTypes = ["hiragana", "katakana", "romaji"];
        const neededTypes = allTypes.filter(
          (type) => !selectedTypes.includes(type),
        );

        if (neededTypes.length > 0) {
          const typeNames = {
            hiragana: "Hiragana (pink)",
            katakana: "Katakana (blue)",
            romaji: "Romaji (green)",
          };
          neededEl.textContent = `Need: ${neededTypes
            .map((t) => typeNames[t])
            .join(" and ")}`;
        } else {
          neededEl.textContent = "Complete! All 3 types selected";
        }
      }

      function drawLine(tile1, tile2) {
        const boardEl = document.getElementById("gameBoard");
        const t1 = document.querySelector(
          `[data-row="${tile1.row}"][data-col="${tile1.col}"]`,
        );
        const t2 = document.querySelector(
          `[data-row="${tile2.row}"][data-col="${tile2.col}"]`,
        );

        if (!t1 || !t2) return;

        const rect1 = t1.getBoundingClientRect();
        const rect2 = t2.getBoundingClientRect();
        const boardRect = boardEl.getBoundingClientRect();

        const x1 = rect1.left + rect1.width / 2 - boardRect.left;
        const y1 = rect1.top + rect1.height / 2 - boardRect.top;
        const x2 = rect2.left + rect2.width / 2 - boardRect.left;
        const y2 = rect2.top + rect2.height / 2 - boardRect.top;

        const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        const angle = (Math.atan2(y2 - y1, x2 - x1) * 180) / Math.PI;

        const line = document.createElement("div");
        line.className = "match-line";
        line.style.width = length + "px";
        line.style.left = x1 + "px";
        line.style.top = y1 + "px";
        line.style.transform = `rotate(${angle}deg)`;

        boardEl.appendChild(line);
      }

      function handleMismatch() {
        isAnimating = true;

        // Add 3-second penalty
        addPenalty(3);

        // Track incorrect attempts for these characters
        const tiles = selectedTiles.map(({ row, col }) => board[row][col]);
        tiles.forEach(tile => {
          if (tile) {
            const kanaIndex = tile.kanaIndex;
            if (!characterStats[kanaIndex]) {
              characterStats[kanaIndex] = {
                attempts: 0,
                incorrect: 0,
                totalTime: 0,
                avgTime: 0
              };
            }
            characterStats[kanaIndex].incorrect++;
          }
        });

        // Add red pulse to background
        document.body.classList.add("error-pulse");

        // Get tile elements and add shake animation
        selectedTiles.forEach(({ row, col }) => {
          const tile = document.querySelector(
            `[data-row="${row}"][data-col="${col}"]`,
          );
          if (tile) {
            tile.classList.add("shake");
          }
        });

        // Clear selection after shake animation
        setTimeout(() => {
          // Remove shake class
          document.querySelectorAll(".tile.shake").forEach((tile) => {
            tile.classList.remove("shake");
          });

          // Remove error pulse
          document.body.classList.remove("error-pulse");

          // Clear selection
          selectedTiles = [];
          updateSelectedTiles();
          updateFadedTiles();
          updateNeededTypes();
          isAnimating = false;
        }, 500);
      }

      function checkMatch() {
        const tiles = selectedTiles.map(({ row, col }) => board[row][col]);

        // Check if all three tiles are from the same kana family
        const kanaIndex = tiles[0].kanaIndex;
        const allSameKana = tiles.every((t) => t.kanaIndex === kanaIndex);

        if (allSameKana) {
          // Valid match!
          processMatch();
        } else {
          // Invalid match - use the same shake animation
          handleMismatch();
        }
      }

      function processMatch() {
        isAnimating = true;
        
        // Track response time for this match
        const responseTime = Date.now() - currentMatchStartTime;
        const tiles = selectedTiles.map(({ row, col }) => board[row][col]);
        const kanaIndex = tiles[0].kanaIndex;
        
        if (!characterStats[kanaIndex]) {
          characterStats[kanaIndex] = {
            attempts: 0,
            incorrect: 0,
            totalTime: 0,
            avgTime: 0
          };
        }
        
        characterStats[kanaIndex].attempts++;
        characterStats[kanaIndex].totalTime += responseTime;
        characterStats[kanaIndex].avgTime = Math.round(
          characterStats[kanaIndex].totalTime / characterStats[kanaIndex].attempts
        );
        
        matches++;
        score += 100;
        updateStats();
        updateProgress();

        // Get tile elements
        const tileElements = selectedTiles.map(({ row, col }) =>
          document.querySelector(`[data-row="${row}"][data-col="${col}"]`),
        );

        // Animate tiles
        tileElements.forEach((tile) => {
          if (tile) {
            tile.classList.add("match-animation");
            createParticles(tile);
          }
        });

        // Show combo text at center
        const centerX = selectedTiles.reduce((sum, t) => sum + t.col, 0) / 3;
        const centerY = selectedTiles.reduce((sum, t) => sum + t.row, 0) / 3;
        showCombo(centerX, centerY);

        setTimeout(() => {
          // Remove tiles from board
          selectedTiles.forEach(({ row, col }) => {
            board[row][col] = null;
          });

          // Clear selection
          selectedTiles = [];
          document
            .querySelectorAll(".match-line")
            .forEach((line) => line.remove());
          updateNeededTypes();

          // Re-render board
          renderBoard();
          
          // Reset match start time for next match
          currentMatchStartTime = Date.now();

          // Check for auto-match condition (only 3 tiles left)
          checkAutoMatch();

          // Check if level complete
          if (matches === totalMatches) {
            setTimeout(() => {
              gameOver();
            }, 500);
          }

          isAnimating = false;
          isAutoMatching = false;
        }, 600);
      }

      function createParticles(tileElement) {
        const rect = tileElement.getBoundingClientRect();
        const boardRect = document
          .getElementById("gameBoard")
          .getBoundingClientRect();
        const x = rect.left + rect.width / 2 - boardRect.left;
        const y = rect.top + rect.height / 2 - boardRect.top;

        const emojis = ["✨", "⭐", "🌟"];

        for (let i = 0; i < 6; i++) {
          const particle = document.createElement("div");
          particle.className = "particle";
          particle.textContent =
            emojis[Math.floor(Math.random() * emojis.length)];
          particle.style.left = x + "px";
          particle.style.top = y + "px";
          particle.style.setProperty(
            "--dx",
            (Math.random() - 0.5) * 150 + "px",
          );
          particle.style.setProperty(
            "--dy",
            (Math.random() - 0.5) * 150 + "px",
          );

          document.getElementById("gameBoard").appendChild(particle);
          setTimeout(() => particle.remove(), 1000);
        }
      }

      function showCombo(gridX, gridY) {
        const boardEl = document.getElementById("gameBoard");
        const x = (gridX + 0.5) * 93 + 20; // 85px tile + 8px gap
        const y = (gridY + 0.5) * 93 + 20;

        const combo = document.createElement("div");
        combo.className = "combo-text";
        combo.textContent = "MATCH!";
        combo.style.left = x + "px";
        combo.style.top = y + "px";

        boardEl.appendChild(combo);
        setTimeout(() => combo.remove(), 1500);
      }

      function checkAutoMatch() {
        // Count remaining tiles
        let remainingTiles = [];
        for (let row = 0; row < 6; row++) {
          for (let col = 0; col < 6; col++) {
            if (board[row][col]) {
              remainingTiles.push({ row, col, tile: board[row][col] });
            }
          }
        }

        // If exactly 3 tiles remain, auto-match them
        if (remainingTiles.length === 3) {
          // Verify they're from the same kana family (they should be)
          const kanaIndex = remainingTiles[0].tile.kanaIndex;
          const allSame = remainingTiles.every(
            (t) => t.tile.kanaIndex === kanaIndex,
          );

          if (allSame) {
            setTimeout(() => performAutoMatch(remainingTiles), 300);
          }
        }
      }

      function performAutoMatch(tiles) {
        isAnimating = true;
        isAutoMatching = true;

        // Don't pause timer during auto-match in stopwatch mode
        // Just mark that we're auto-matching
        isAutoMatching = true;

        // Sort tiles to ensure consistent order: hiragana, katakana, romaji
        const typeOrder = { hiragana: 0, katakana: 1, romaji: 2 };
        tiles.sort((a, b) => typeOrder[a.tile.type] - typeOrder[b.tile.type]);

        // Animate selection of each tile with delay
        tiles.forEach((tileData, index) => {
          setTimeout(() => {
            selectedTiles.push({ row: tileData.row, col: tileData.col });
            updateSelectedTiles();
            updateFadedTiles();
            updateNeededTypes();

            // After all three are selected, process the match
            if (index === 2) {
              setTimeout(() => {
                checkMatch();
                // Resume timer after match is processed (will happen in processMatch)
              }, 400);
            }
          }, index * 250); // 250ms delay between each selection
        });
      }

      function showHint() {
        if (isAnimating) return;

        // Clear current selection first
        selectedTiles = [];
        updateSelectedTiles();
        updateFadedTiles();
        updateNeededTypes();

        // Find an unmatched set
        const groups = {};

        for (let row = 0; row < 6; row++) {
          for (let col = 0; col < 6; col++) {
            const tile = board[row][col];
            if (!tile) continue;

            if (!groups[tile.kanaIndex]) {
              groups[tile.kanaIndex] = [];
            }
            groups[tile.kanaIndex].push({ row, col, type: tile.type });
          }
        }

        // Find first complete set
        for (let kanaIndex in groups) {
          const tiles = groups[kanaIndex];
          const types = {};

          tiles.forEach((t) => {
            if (!types[t.type]) types[t.type] = t;
          });

          if (types.hiragana && types.katakana && types.romaji) {
            // Highlight these tiles
            [types.hiragana, types.katakana, types.romaji].forEach((t) => {
              const tile = document.querySelector(
                `[data-row="${t.row}"][data-col="${t.col}"]`,
              );
              if (tile) {
                tile.style.animation = "none";
                setTimeout(() => {
                  tile.style.boxShadow = "0 0 30px #ffd700";
                  tile.style.transform = "scale(1.1)";
                }, 10);
                setTimeout(() => {
                  tile.style.boxShadow = "";
                  tile.style.transform = "";
                }, 2000);
              }
            });
            break;
          }
        }
      }

      function showMessage(text) {
        const msg = document.getElementById("message");
        msg.textContent = text;
        msg.classList.add("show");

        setTimeout(() => {
          msg.classList.remove("show");
        }, 2000);
      }

      function updateStats() {
        document.getElementById("score").textContent = score;
        document.getElementById("matches").textContent = matches;
        document.getElementById("totalMatches").textContent = totalMatches;
      }

      function updateProgress() {
        const percentage = (matches / totalMatches) * 100;
        document.getElementById("progressFill").style.width = percentage + "%";
      }

      function startTimer() {
        timerInterval = setInterval(() => {
          if (isGameOver) return;

          timeElapsed++;
          updateTimer();
        }, 1000);
      }

      function updateTimer() {
        const timerEl = document.getElementById("timer");
        timerEl.textContent = timeElapsed;
      }

      function addPenalty(seconds) {
        const timerStatEl = document.querySelector(".stat.timer");

        // Add penalty time
        timeElapsed += seconds;
        updateTimer();

        // Visual feedback for penalty
        timerStatEl.classList.add("penalty");

        // Show penalty text
        const timerEl = document.getElementById("timer");
        const originalContent = timerEl.innerHTML;
        timerEl.innerHTML = timeElapsed + ' <span style="color:#ff6b6b">+3</span>';

        setTimeout(() => {
          timerStatEl.classList.remove("penalty");
          timerEl.innerHTML = timeElapsed;
        }, 1000);
      }

      function gameOver() {
        isGameOver = true;
        clearInterval(timerInterval);

        // Disable all tiles
        document.querySelectorAll(".tile").forEach((tile) => {
          tile.style.pointerEvents = "none";
          tile.style.opacity = "0.5";
        });

        showMessage("Level Complete!");

        // Show character statistics
        setTimeout(() => {
          showCharacterStats();
        }, 2000);
      }

      function showCharacterStats() {
        let statsMessage = "Character Performance:\n\n";
        
        // Sort characters by difficulty (incorrect attempts + avg time)
        const sortedStats = Object.entries(characterStats)
          .filter(([_, stats]) => stats.attempts > 0)
          .sort((a, b) => {
            const difficultyA = a[1].incorrect + (a[1].avgTime / 1000);
            const difficultyB = b[1].incorrect + (b[1].avgTime / 1000);
            return difficultyB - difficultyA;
          })
          .slice(0, 5); // Show top 5 most difficult
        
        if (sortedStats.length > 0) {
          statsMessage += "Most Challenging Characters:\n";
          sortedStats.forEach(([kanaIndex, stats]) => {
            const kana = kanaMap[kanaIndex];
            const accuracy = Math.round(((stats.attempts - stats.incorrect) / stats.attempts) * 100);
            statsMessage += `${kana.hiragana}/${kana.katakana}/${kana.romaji}: `;
            statsMessage += `${stats.avgTime / 1000}s avg, ${accuracy}% accuracy\n`;
          });
        }
        
        statsMessage += `\nTotal time: ${timeElapsed}s\nScore: ${score}`;
        statsMessage += "\n\nPlay again?";
        
        if (confirm(statsMessage)) {
          level = 1;
          initGame();
        }
      }

      // Initialize the game
      initGame();
      
      // Debug: Press 'd' to toggle character stats display
      document.addEventListener('keydown', (e) => {
        if (e.key === 'd') {
          const debugEl = document.getElementById('charStatsDebug');
          if (debugEl.style.display === 'none') {
            debugEl.style.display = 'block';
            updateDebugStats();
          } else {
            debugEl.style.display = 'none';
          }
        }
      });
      
      function updateDebugStats() {
        const debugEl = document.getElementById('charStatsDebug');
        if (!debugEl || debugEl.style.display === 'none') return;
        
        let html = '<h3>Character Statistics</h3>';
        const sortedStats = Object.entries(characterStats)
          .filter(([_, stats]) => stats.attempts > 0)
          .sort((a, b) => b[1].avgTime - a[1].avgTime);
        
        if (sortedStats.length === 0) {
          html += '<p>No data yet - start matching!</p>';
        } else {
          html += '<table style="width:100%; text-align:left;">';
          html += '<tr><th>Character</th><th>Avg Time</th><th>Attempts</th><th>Errors</th><th>Accuracy</th></tr>';
          
          sortedStats.forEach(([kanaIndex, stats]) => {
            const kana = kanaMap[kanaIndex];
            const accuracy = Math.round(((stats.attempts - stats.incorrect) / stats.attempts) * 100);
            html += '<tr>';
            html += `<td>${kana.hiragana}/${kana.katakana}/${kana.romaji}</td>`;
            html += `<td>${(stats.avgTime / 1000).toFixed(1)}s</td>`;
            html += `<td>${stats.attempts}</td>`;
            html += `<td>${stats.incorrect}</td>`;
            html += `<td>${accuracy}%</td>`;
            html += '</tr>';
          });
          html += '</table>';
        }
        
        debugEl.innerHTML = html;
      }
      
      // Update debug stats periodically if visible
      setInterval(updateDebugStats, 1000);

      // Prevent pull-to-refresh and overscroll on mobile
      document.addEventListener(
        "touchmove",
        function (e) {
          e.preventDefault();
        },
        { passive: false },
      );

      // Prevent double-tap zoom
      let lastTouchEnd = 0;
      document.addEventListener(
        "touchend",
        function (e) {
          const now = Date.now();
          if (now - lastTouchEnd <= 300) {
            e.preventDefault();
          }
          lastTouchEnd = now;
        },
        false,
      );
    </script>
  </body>
</html>
